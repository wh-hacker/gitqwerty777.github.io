<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>gcc參數介紹 | QWERTY</title>
  <meta name="author" content="HCL">
  
  <meta name="description" content="Programming, Computer Science, Note">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="gcc參數介紹"/>
  <meta property="og:site_name" content="QWERTY"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-51310670-1', 'auto');
  ga('send', 'pageview');
</script>




  <script src="https://leancloud.cn/scripts/lib/av-0.4.6.min.js"></script>
  <script>AV.initialize("j1wjgh5yjwypwyod6e73zq5pjr9bqgsjhlsnfi6fph67olbx", "lscxm6j2o23yn0vytcywijf1xzy0pwj826eey87aw6ndq9rf");</script>

</head>



 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">QWERTY</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">		
			<h1> gcc參數介紹</h1>
		</div>		
	



<div class="row post">
	<!-- cols -->
	
	<div class="col-md-9">
	

			

	<!-- content -->
	<div class="mypage">		
	    <h3 id="使用方式">使用方式</h3><pre><code>gcc [<span class="keyword">option</span>] filename
</code></pre><h3 id="常用">常用</h3><p>-c : 只做編譯(不做連結，產生.o檔)<br>-S : 輸出組譯碼<br>-E : 將預處理結果顯示<br>-o filename : 指定輸出檔名<br>-ansi : 程式要求依據ansi c標準<br>-Dmacro : 使定義巨集(marco)為有效<br>-Dmarco=defn : 使定義巨集(marco)為defn<br>-Wa,option : 將選項(option)傳給組譯器<br>-wl,option : 將選項(option)傳給連結器<br>-I : 追加include檔案的搜尋路徑<br>-L : 追加library檔案的搜尋路徑<br>-l : 指定連結的函式庫<br>-Wall : 顯示所有的警告訊息<br>-g : 編入除錯資訊(要使用GDB除錯一定要加)<br>-O2 : 做最佳化<br>※ 使用範例</p>
<pre><code>Example:

gcc -o file <span class="tag">a</span><span class="class">.c</span> <span class="tag">b</span><span class="class">.c</span> c<span class="class">.c</span>
gcc -Wall -g -o test test<span class="class">.c</span>
gcc -Iinclude -Llibrary -lmy_lib -o test1 test1<span class="class">.c</span>
gcc -DDEBUG_ON -o test2 test2<span class="class">.c</span>
gcc -c -o test3 test.c
</code></pre><a id="more"></a>
<p>身為一種集所有功能大成的處理器, gcc 可以像下面這樣來執行, 從許多的C原始程式檔產生可執行檔 :<br>%gcc -o filter filter_driver.c define_stack.c<br>-o <filename> ：告訴 gcc 將產生的執行檔命名為 filter. 假如你不指定 -o參數, gcc 會內定 a.out 為所產出的執行檔檔名, 這樣的檔名看不出任何意義 (還會造成執行檔彼此互相覆蓋)</filename></p>
<p>分開編譯:<br>%gcc -c filter_driver.c<br>%gcc -c define_stack.c<br>%gcc filter filter_driver.o define_stack.o</p>
<p>-c 選項表示 “編譯但不連結”. 所以gcc 會在編譯完成後, 從原始檔案 filter_driver.c 建立目的檔 filter_driver.o ; 最後, 所有的目的檔被連結成可執行檔. 因為最後的命令中都是目的檔, 所以不需要任何編譯及組譯 : gcc 只會啟動連結器. 使用 gcc 來啟動連結器比單獨用 ld要好 ; gcc 會確保程式跟正確的函數庫和原始程式作連結. 另外假使你包括一個非標準 (或非預設) 的目錄下的標頭檔, 必須使用 -I 來指定這個目錄. 例如你的原始程式在 /usr/src 目錄下, 標頭檔在 /usr/include 目錄, 當你在 /usr/src 目錄下進行編譯時, 必須透過下面命令告訴 gcc 到哪裡尋找表頭檔 :<br>%gcc -c -I../include/headers filter_driver.c</p>
<p>與函式庫連結 :<br>另一個常用的選項是 -l, 它以一種特殊方式來指定函式庫. 首先它必須放在命令的最後面, 也就是原始檔檔名之後, 而所有其他的選項是指定在檔名之前. 底下是一個典型的命令 ; 因為輸入檔是目的檔, 所以命令僅僅啟動連結器 :<br>%gcc -o plot main.o plot_line.o -lm</p>
<p>-lm 選項指定使用數學函式庫. 當你指定 -lname, 系統會到存放標準函式庫的目錄中 (通常位於 /usr/lib) 中去尋找 libname.a 檔案. 所以你所尋找的數學函式庫應該是 /usr/lib/libm.a . 和表頭檔一樣, 函式庫有時也放在非標準路徑的目錄下. 你這時必須以 -L 選項來告訴 gcc 到哪裡去找這函式庫, 例如 :<br>%gcc -o -L/src/local/lib main.o plot_line.o -lm</p>
<p>它告訴gcc 首先到 /src/local/lib 去找函式庫, 然後才是標準路徑下的函式庫. 假如某人把自己版本的函式庫放到 /src/local/lib 下, 在使用順序上, 他的這個版本將超過 /usr/lib 下的同名函式庫.</p>
<p>make 與 C 編譯器 :<br>make 是 UNIX 中最重要的工具之一, 也是需多程式設計師未能善用的工具之一, 即使是資深的UNIX 程式設計師, 也往往忽略了這個現成工具的重要性. 它用來進行自動編譯的程式工具. 一旦你建立了 makefile, 詳細敘述如何建構你的可執行檔, make 就會自動檢查哪些目的檔已經過期, 以最新的原始程式重新編譯這些檔案, 並連結成可執行檔. GNU 版的 make (通常稱為 gmake, 有時也稱gnumake) 功能超強, 將會省去你不少時間. 對於大型應用程式開發, make 是不可或缺的工具, 不但可以免去你要去記住哪個目的檔的模組是在何時編譯, 更可以按照你的設定進行函式庫的連結.</p>
<p>補充說明 :<br>@. CLDB — Linux 中文文件計畫 : GCC 安裝與GCC 設定<br>@. An Introduction to GCC - for the GNU compilers gcc and g++<br>@. What is GNU Mame?</p>
<pre><code>Make <span class="keyword">is</span> a tool which controls <span class="keyword">the</span> generation <span class="keyword">of</span> executables <span class="keyword">and</span> other non-source files <span class="keyword">of</span> a program <span class="keyword">from</span> <span class="keyword">the</span> program's source files.
Make gets <span class="keyword">its</span> knowledge <span class="keyword">of</span> how <span class="keyword">to</span> build your program <span class="keyword">from</span> a <span class="type">file</span> called <span class="keyword">the</span> makefile, which lists each <span class="keyword">of</span> <span class="keyword">the</span> non-source files <span class="keyword">and</span> how <span class="keyword">to</span> compute <span class="keyword">it</span> <span class="keyword">from</span> other files. When you <span class="command">write</span> a program, you should <span class="command">write</span> a makefile <span class="keyword">for</span> <span class="keyword">it</span>, so <span class="keyword">that</span> <span class="keyword">it</span> <span class="keyword">is</span> possible <span class="keyword">to</span> use Make <span class="keyword">to</span> build <span class="keyword">and</span> install <span class="keyword">the</span> program.
</code></pre><hr>
<p>gcc 優化選項 -O1 -O2 -O3 -Os 優先級，-fomit-frame-pointer<br>2010-07-30 12:27 18828人閱讀 評論(2) 收藏 舉報<br>gcc優化optimization編譯器compilation彙編<br>少優化-&gt;多優化：<br>O0 —&gt;&gt; O1 —&gt;&gt; O2 —&gt;&gt; O3<br>-O0表示沒有優化,-O1為缺省值，-O3優化級別最高</p>
<p>英文解析：<br><code>-O &#39;</code>-O1 ‘<br>                Optimize.      Optimizing   compilation   takes   somewhat   more   time,   and   a<br>                lot   more   memory   for   a   large   function. </p>
<pre><code>With   `-O ',   the   compiler   tries   to   reduce   code   size   and   execution 
time,   without   performing   any   optimizations   that   take   a   great   deal 
of   compilation   time. 

`-O '   turns   on   the   following   optimization   flags: 
               -<span class="ruby">fdefer-pop    
</span>               -<span class="ruby">fdelayed-branch    
</span>               -<span class="ruby">fguess-branch-probability    
</span>               -<span class="ruby">fcprop-registers    
</span>               -<span class="ruby">floop-optimize    
</span>               -<span class="ruby">fif-conversion    
</span>               -<span class="ruby">fif-conversion2    
</span>               -<span class="ruby">ftree-ccp    
</span>               -<span class="ruby">ftree-dce    
</span>               -<span class="ruby">ftree-dominator-opts    
</span>               -<span class="ruby">ftree-dse    
</span>               -<span class="ruby">ftree-ter    
</span>               -<span class="ruby">ftree-lrs    
</span>               -<span class="ruby">ftree-sra    
</span>               -<span class="ruby">ftree-copyrename    
</span>               -<span class="ruby">ftree-fre    
</span>               -<span class="ruby">ftree-ch    
</span>               -<span class="ruby">funit-at-a-time    
</span>               -<span class="ruby">fmerge-constants 
</span>
`-O '   also   turns   on   `-fomit-frame-pointer '   on   machines   where   doing 
so   does   not   interfere   with   debugging. 

`-O '   doesn 't   turn   on   `-ftree-sra '   for   the   Ada   compiler.      This 
option   must   be   explicitly   specified   on   the   command   line   to   be 
enabled   for   the   Ada   compiler. 
</code></pre><p><code>-O2 &#39; 
                Optimize   even   more.      GCC   performs   nearly   all   supported 
                optimizations   that   do   not   involve   a   space-speed   tradeoff.      The 
                compiler   does   not   perform   loop   unrolling   or   function   inlining   when 
                you   specify</code>-O2 ‘.      As   compared   to   `-O ‘,   this   option   increases<br>                both   compilation   time   and   the   performance   of   the   generated   code. </p>
<pre><code>`-O2 '   turns   on   all   optimization   flags   specified   by   `-O '.      It   also 
turns   on   the   following   optimization   flags: 
               -<span class="ruby">fthread-jumps    
</span>               -<span class="ruby">fcrossjumping    
</span>               -<span class="ruby">foptimize-sibling-calls    
</span>               -<span class="ruby">fcse-follow-jumps      -fcse-skip-blocks    
</span>               -<span class="ruby">fgcse      -fgcse-lm       
</span>               -<span class="ruby">fexpensive-optimizations    
</span>               -<span class="ruby">fstrength-reduce    
</span>               -<span class="ruby">frerun-cse-after-loop      -frerun-loop-opt    
</span>               -<span class="ruby">fcaller-saves    
</span>               -<span class="ruby">fpeephole2    
</span>               -<span class="ruby">fschedule-insns      -fschedule-insns2    
</span>               -<span class="ruby">fsched-interblock      -fsched-spec    
</span>               -<span class="ruby">fregmove    
</span>               -<span class="ruby">fstrict-aliasing    
</span>               -<span class="ruby">fdelete-null-pointer-checks    
</span>               -<span class="ruby">freorder-blocks      -freorder-functions    
</span>               -<span class="ruby">falign-functions      -falign-jumps    
</span>               -<span class="ruby">falign-loops      -falign-labels    
</span>               -<span class="ruby">ftree-vrp    
</span>               -<span class="ruby">ftree-pre 
</span>
Please   note   the   warning   under   `-fgcse '   about   invoking   `-O2 '   on 
programs   that   use   computed   gotos. 
</code></pre><p><code>-O3 &#39; 
                Optimize   yet   more.</code>-O3 ‘   turns   on   all   optimizations   specified   by<br>                <code>-O2 &#39;   and   also   turns   on   the</code>-finline-functions ‘,<br>                <code>-funswitch-loops &#39;   and</code>-fgcse-after-reload ‘   options. </p>
<p>`-O0 ‘<br>                Do   not   optimize.      This   is   the   default. </p>
<p>///==================另外還有個Os選項==========================<br><a href="http://hi.baidu.com/ah__fu/blog/item/cc9fd19b801948bdc9eaf4b3.html" target="_blank" rel="external">http://hi.baidu.com/ah__fu/blog/item/cc9fd19b801948bdc9eaf4b3.html</a><br>在研究編譯驅動的makefile的時候，發現GCC的命令行裡面有一個-Os的優化選項。<br>    遍查GCC文檔，發現了-O0, -O1, -O2, -O3，就是沒有發現-Os。<br>    祭出GOOGLE大法搜了一下，終於發現這篇文章說明了-Os的作用：<br><a href="http://www.linuxjournal.com/article/7269" target="_blank" rel="external">http://www.linuxjournal.com/article/7269</a></p>
<p>   原來-Os相當於-O2.5。是使用了所有-O2的優化選項，但又不縮減代碼尺寸的方法。<br>   詳細的說明如下：<br>Level 2.5 (-Os)<br>The special optimization level (-Os or size) enables all -O2 optimizations that do not increase code size; it puts the emphasis on size over speed. This includes all second-level optimizations, except for the alignment optimizations. The alignment optimizations skip space to align functions, loops, jumps and labels to an address that is a multiple of a power of two, in an architecture-dependent manner. Skipping to these boundaries can increase performance as well as the size of the resulting code and data spaces; therefore, these particular optimizations are disabled. The size optimization level is enabled as:<br>gcc -Os -o test test.c<br>In gcc 3.2.2, reorder-blocks is enabled at -Os, but in gcc 3.3.2 reorder-blocks is disabled.</p>
<p>==============================<br>補充：在GCC的官方文檔裡又發現了關於-Os的說明：<br><a href="http://gcc.gnu.org/onlinedocs/gcc-3.4.6/gcc/Optimize-Options.html#Optimize-Options" target="_blank" rel="external">http://gcc.gnu.org/onlinedocs/gcc-3.4.6/gcc/Optimize-Options.html#Optimize-Options</a></p>
<p>//=============================================<br><a href="http://blog.csdn.net/ison81/archive/2009/05/07/4158576.aspx" target="_blank" rel="external">http://blog.csdn.net/ison81/archive/2009/05/07/4158576.aspx</a></p>
<p>backtrace與fomit-frame-pointer選項</p>
<p>事實上gcc的所有級別的優化（-O, -O2, -O3等）都會打開-fomit-frame-pointer，該選項的功能是函數調用時不保存frame指針，在ARM上就是fp，故我們無法按照APCS中的約定來回溯調用棧。但是GDB中仍然可以使用bt命令看到調用棧，為什麼？得知GDB v6之後都是支持DWARF2的，也就意味著它可以不依賴fp來回溯調用棧（詳見<a href="http://gcc.gnu.org/ml/gcc/2003-10/msg00322.html）。" target="_blank" rel="external">http://gcc.gnu.org/ml/gcc/2003-10/msg00322.html）。</a><br>看來想在代碼中動態顯示調用棧而又不希望使用GDB的朋友，只能在編譯時關掉-fomit-frame-pointer了。</p>
<p>//==================gcc參數大全：===========================</p>
<p>[介紹]<br>gcc and g++分別是gnu的c &amp; c++編譯器 gcc/g++在執行編譯工作的時候，總共需要4步<br>1.預處理,生成.i的文件[預處理器cpp]<br>2.將預處理後的文件不轉換成彙編語言,生成文件.s[編譯器egcs]<br>3.有彙編變為目標代碼(機器代碼)生成.o的文件[彙編器as]<br>4.連接目標代碼,生成可執行程序[鏈接器ld]<br>[參數詳解]<br>-x language filename<br>　設定文件所使用的語言,使後綴名無效,對以後的多個有效.也就是根據約定C語言的後綴名稱是.c的，而C++的後綴名是.C或者.cpp,如果你很個性，決定你的C代碼文件的後綴名是.pig 哈哈，那你就要用這個參數,這個參數對他後面的文件名都起作用，除非到了下一個參數的使用。<br>　　可以使用的參數嗎有下面的這些<br>　　<code>c&#39;,</code>objective-c’, <code>c-header&#39;,</code>c++’, <code>cpp-output&#39;,</code>assembler’, and `assembler-with-cpp’.<br>　　看到英文，應該可以理解的。<br>　　例子用法:<br>　　gcc -x c hello.pig<br>　　<br>-x none filename<br>　　關掉上一個選項，也就是讓gcc根據文件名後綴，自動識別文件類型<br>　　例子用法:<br>　　gcc -x c hello.pig -x none hello2.c<br>　　<br>-c<br>　　只激活預處理,編譯,和彙編,也就是他只把程序做成obj文件<br>　　例子用法:<br>　　gcc -c hello.c<br>　　他將生成.o的obj文件<br>-S<br>　　只激活預處理和編譯，就是指把文件編譯成為彙編代碼。<br>　　例子用法<br>　　gcc -S hello.c<br>　　他將生成.s的彙編代碼，你可以用文本編輯器察看<br>-E<br>　　只激活預處理,這個不生成文件,你需要把它重定向到一個輸出文件裡面.<br>　　例子用法:<br>　　gcc -E hello.c &gt; pianoapan.txt<br>　　gcc -E hello.c | more<br>　　慢慢看吧,一個hello word 也要與處理成800行的代碼<br>-o<br>　　制定目標名稱,缺省的時候,gcc 編譯出來的文件是a.out,很難聽,如果你和我有同感，改掉它,哈哈<br>　　例子用法<br>　　gcc -o hello.exe hello.c (哦,windows用習慣了)<br>　　gcc -o hello.asm -S hello.c<br>-pipe<br>　　使用管道代替編譯中臨時文件,在使用非gnu彙編工具的時候,可能有些問題<br>　　gcc -pipe -o hello.exe hello.c<br>-ansi<br>　　關閉gnu c中與ansi c不兼容的特性,激活ansi c的專有特性(包括禁止一些asm inline typeof關鍵字,以及UNIX,vax等預處理宏,<br>-fno-asm<br>　　此選項實現ansi選項的功能的一部分，它禁止將asm,inline和typeof用作關鍵字。 　　　　<br>-fno-strict-prototype<br>　　只對g++起作用,使用這個選項,g++將對不帶參數的函數,都認為是沒有顯式的對參數的個數和類型說明,而不是沒有參數.<br>　　而gcc無論是否使用這個參數,都將對沒有帶參數的函數,認為城沒有顯式說明的類型<br>　　<br>-fthis-is-varialble<br>　　就是向傳統c++看齊,可以使用this當一般變量使用.<br>　　<br>-fcond-mismatch<br>　　允許條件表達式的第二和第三參數類型不匹配,表達式的值將為void類型<br>　　<br>-funsigned-char<br>-fno-signed-char<br>-fsigned-char<br>-fno-unsigned-char<br>　　這四個參數是對char類型進行設置,決定將char類型設置成unsigned char(前兩個參數)或者 signed char(後兩個參數)<br>　　<br>-include file<br>　　包含某個代碼,簡單來說,就是便以某個文件,需要另一個文件的時候,就可以用它設定,功能就相當於在代碼中使用#include<filename><br>　　例子用法:<br>　　gcc hello.c -include /root/pianopan.h<br>　　<br>-imacros file<br>　　將file文件的宏,擴展到gcc/g++的輸入文件,宏定義本身並不出現在輸入文件中<br>　　<br>-Dmacro<br>　　相當於C語言中的#define macro<br>　　<br>-Dmacro=defn<br>　　相當於C語言中的#define macro=defn<br>　　<br>-Umacro<br>　　相當於C語言中的#undef macro<br>-undef<br>　　取消對任何非標準宏的定義<br>　　<br>-Idir<br>　　在你是用#include”file”的時候,gcc/g++會先在當前目錄查找你所制定的頭文件,如果沒有找到,他回到缺省的頭文件目錄找,如果使用-I制定了目錄,他<br>　　回先在你所制定的目錄查找,然後再按常規的順序去找.<br>　　對於#include<file>,gcc/g++會到-I制定的目錄查找,查找不到,然後將到系統的缺省的頭文件目錄查找<br>　　<br>-I-<br>　　就是取消前一個參數的功能,所以一般在-Idir之後使用<br>　　<br>-idirafter dir<br>　　在-I的目錄裡面查找失敗,講到這個目錄裡面查找.<br>　　<br>-iprefix prefix<br>-iwithprefix dir<br>　　一般一起使用,當-I的目錄查找失敗,會到prefix+dir下查找<br>　　<br>-nostdinc<br>　　使編譯器不再系統缺省的頭文件目錄裡面找頭文件,一般和-I聯合使用,明確限定頭文件的位置<br>　　<br>-nostdin C++<br>　　規定不在g++指定的標準路經中搜索,但仍在其他路徑中搜索,.此選項在創libg++庫使用<br>　　<br>-C<br>　　在預處理的時候,不刪除註釋信息,一般和-E使用,有時候分析程序，用這個很方便的<br>　　<br>-M<br>　　生成文件關聯的信息。包含目標文件所依賴的所有源代碼你可以用gcc -M hello.c來測試一下，很簡單。<br>　　<br>-MM<br>　　和上面的那個一樣，但是它將忽略由#include<file>造成的依賴關係。<br>　　<br>-MD<br>　　和-M相同，但是輸出將導入到.d的文件裡面<br>　　<br>-MMD<br>　　和-MM相同，但是輸出將導入到.d的文件裡面<br>　　<br>-Wa,option<br>　　此選項傳遞option給彙編程序;如果option中間有逗號,就將option分成多個選項,然後傳遞給會彙編程序<br>　　<br>-Wl.option<br>　　此選項傳遞option給連接程序;如果option中間有逗號,就將option分成多個選項,然後傳遞給會連接程序.<br>-llibrary<br>　　制定編譯的時候使用的庫<br>　　例子用法<br>　　gcc -lcurses hello.c<br>　　使用ncurses庫編譯程序<br>　　<br>-Ldir<br>　　制定編譯的時候，搜索庫的路徑。比如你自己的庫，可以用它制定目錄，不然<br>　　編譯器將只在標準庫的目錄找。這個dir就是目錄的名稱。<br>　　<br>-O0<br>-O1<br>-O2<br>-O3<br>　　編譯器的優化選項的4個級別，-O0表示沒有優化,-O1為缺省值，-O3優化級別最高　　 　　<br>-g<br>　　只是編譯器，在編譯的時候，產生調試信息。<br>　　<br>-gstabs<br>　　此選項以stabs格式聲稱調試信息,但是不包括gdb調試信息.<br>　　<br>-gstabs+<br>　　此選項以stabs格式聲稱調試信息,並且包含僅供gdb使用的額外調試信息.<br>　　<br>-ggdb<br>　　此選項將儘可能的生成gdb的可以使用的調試信息.<br>-static<br>　　此選項將禁止使用動態庫，所以，編譯出來的東西，一般都很大，也不需要什麼<br>動態連接庫，就可以運行.<br>-share<br>　　此選項將儘量使用動態庫，所以生成文件比較小，但是需要系統由動態庫.<br>-traditional<br>　　試圖讓編譯器支持傳統的C語言特性<br>[參考資料]<br>-Linux/UNIX高級編程<br>　　中科紅旗軟件技術有限公司編著.清華大學出版社出版<br>-Gcc man page<br>　　<br>[ChangeLog]<br>-2002-08-10<br>　　ver 0.1 發佈最初的文檔<br>-2002-08-11<br>　　ver 0.11 修改文檔格式<br>-2002-08-12<br>　　ver 0.12 加入了對靜態庫，動態庫的參數<br>-2002-08-16<br>　　ver 0.16 增加了gcc編譯的4個階段的命令<br>運行 gcc/egcs<br><strong><strong>**</strong></strong>運行 gcc/egcs<strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong><br>　　GCC 是 GNU 的 C 和 C++ 編譯器。實際上，GCC 能夠編譯三種語言：C、C++ 和 Object C（C 語言的一種面向對象擴展）。利用 gcc 命令可同時編譯並連接 C 和 C++ 源程序。<br>　　如果你有兩個或少數幾個 C 源文件，也可以方便地利用 GCC 編譯、連接並生成可執行文件。例如，假設你有兩個源文件 main.c 和 factorial.c 兩個源文件，現在要編譯生成一個計算階乘的程序。 </file></file></filename></p>
<h2 id="代碼:">代碼:</h2><h2 id="清單_factorial-c">清單 factorial.c </h2><p>int factorial (int n)<br>{<br>　　if (n &lt;= 1)<br>　　　return 1;<br>　　else<br>　　　return factorial (n - 1) * n; </p>
<h2 id="}">} </h2><h2 id="清單_main-c">清單 main.c </h2><h1 id="include">include　<stdio.h></stdio.h></h1><h1 id="include-1">include　<unistd.h></unistd.h></h1><p>int factorial (int n);<br>int main (int argc, char **argv)<br>{<br>　　int n;<br>　　if (argc &lt; 2)<br>　　{<br>　　　　printf (“Usage: %s n/n”, argv [0]);<br>　　　　return -1;<br>　　}<br>　　else<br>　　{<br>　　　n = atoi (argv[1]);<br>　　　printf (“Factorial of %d is %d./n”, n, factorial (n));<br>　　 }<br>　　return 0;<br>}</p>
<hr>
<p>利用如下的命令可編譯生成可執行文件，並執行程序：<br>$ gcc -o factorial main.c factorial.c<br>$ ./factorial 5<br>Factorial of 5 is 120.<br>　　GCC 可同時用來編譯 C 程序和 C++ 程序。一般來說，C 編譯器通過源文件的後綴名來判斷是 C 程序還是 C++ 程序。在 Linux 中，C 源文件的後綴名為 .c，而 C++ 源文件的後綴名為 .C 或 .cpp。但是，gcc 命令只能編譯 C++ 源文件，而不能自動和 C++ 程序使用的庫連接。因此，通常使用 g++ 命令來完成 C++ 程序的編譯和連接，該程序會自動調用 gcc 實現編譯。假設我們有一個如下的 C++ 源文件（hello.C）： </p>
<h1 id="include-2">include <iostream></iostream></h1><p>void main (void)<br>{<br>　　cout &lt;&lt; “Hello, world!” &lt;&lt; endl;<br>}<br>則可以如下調用 g++ 命令編譯、連接並生成可執行文件：<br>$ g++ -o hello hello.C<br>$ ./hello<br>Hello, world!</p>
<p><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong>gcc/egcs 的主要選項<strong><strong>*</strong></strong><br>gcc 命令的常用選項<br>選項 解釋<br>-ansi 只支持 ANSI 標準的 C 語法。這一選項將禁止 GNU C 的某些特色，<br>例如 asm 或 typeof 關鍵詞。<br>-c 只編譯並生成目標文件。<br>-DMACRO 以字符串“1”定義 MACRO 宏。<br>-DMACRO=DEFN 以字符串“DEFN”定義 MACRO 宏。<br>-E 只運行 C 預編譯器。<br>-g 生成調試信息。GNU 調試器可利用該信息。<br>-IDIRECTORY 指定額外的頭文件搜索路徑DIRECTORY。<br>-LDIRECTORY 指定額外的函數庫搜索路徑DIRECTORY。<br>-lLIBRARY 連接時搜索指定的函數庫LIBRARY。<br>-m486 針對 486 進行代碼優化。<br>-o FILE 生成指定的輸出文件。用在生成可執行文件時。<br>-O0 不進行優化處理。<br>-O 或 -O1 優化生成代碼。<br>-O2 進一步優化。<br>-O3 比 -O2 更進一步優化，包括 inline 函數。<br>-shared 生成共享目標文件。通常用在建立共享庫時。<br>-static 禁止使用共享連接。<br>-UMACRO 取消對 MACRO 宏的定義。<br>-w 不生成任何警告信息。<br>-Wall 生成所有警告信息。</p>
<p><a href="http://blog.csdn.net/lanmanck/article/details/5776173" target="_blank" rel="external">http://blog.csdn.net/lanmanck/article/details/5776173</a></p>
<hr>
<p>Clang 比 GCC 好在哪裡？</p>
<p>編譯速度更快、編譯產出更小、出錯提示更友好。尤其是在比較極端的情況下。</p>
<p>兩年多前曾經寫過一個Scheme解釋器，詞法分析和語法解析部分大約2000行，用的是Boost.Spirit——一個重度依賴C++模版元編程的框架。當時用g++ 4.2編譯的情況是：<br>編譯速度極慢：完整編譯一次需要20分鐘<br>編譯過程中內存消耗極大：單個g++實例內存峰值消耗超過1G<br>中間產出物極大：編譯出的所有.o文件加在一起大約1~2G，debug鏈接產物超過200M<br>編譯錯誤極其難以理解：編譯錯誤經常長達幾十K，基本不可讀，最要命的是編譯錯誤經常會長到被g++截斷，看不到真正出錯的位置，基本上只能靠裸看代碼來調試<br>這裡先不論我使用Spirit的方式是不是有問題，或者Spirit框架自身的問題。我當時因為實在忍受不了g++，轉而嘗試clang。當時用的是clang 2.8，剛剛可以完整編譯Boost，效果讓我很滿意：<br>編譯速度有顯著提升，記得大約是g++的1/3或1/4<br>編譯過程中的內存消耗差別好像不大<br>中間產出物及最終鏈接產物，記得也是g++的1/3或1/4<br>相較於g++，編譯錯誤可讀性有所飛躍，至少不會出現編譯錯誤過長被截斷的問題了<br>當時最大的缺點是clang編譯出的可執行文件無法用gdb調試，需要用調試器的時候還得用g++再編譯一遍。不過這個問題後來解決了，我不知道是clang支持了gdb還是gdb支持了clang。至少我當前在Ubuntu下用clang 3.0編譯出的二進制文件已經可以順利用gdb調試了。</p>
<p>最後一點，其他同學也有講到，就是Clang採用的是BSD協議。這是蘋果資助LLVM、FreeBSD淘汰GCC換用Clang的一個重要原因。</p>
<hr>
<p>從代碼上說，clang結構更簡單。因為clang只需要完成詞法和語法分析，代碼優化和機器代碼的生成工作由llvm完成。所以和全部由自己包下的gcc比起來，clang可以更專注地做好一件事。</p>
<p>這種結構也使clang可以被單獨拿出來用在其他的程序裡。比如vim的clang_complete插件就是利用clang進行語法分析後給出精確的自動補全和語法錯誤</p>
<hr>
<p>llvm是一個底層虛擬機平台，提供了經過最佳化的IF代碼，也就是有個中間層，在這個中間層可以做很多的事情，比如優化和提供給編譯器更多的信息，理論上可以支持幾乎任何編程語言。llvm默認的前端是clang，當然也可以用gcc做前端。<br>llvm用c++寫的，模塊化做的很好，因此可以很好的和clang，gcc等等更多的東西合作，能為ide提供更全的有用信息。而gcc則包含的比較全面，整一個是一個宏結構，沒有模塊化設計，用c寫的，對ide也不太友好(實際上linux社區裡似乎對ide一直不感冒)。不過c++版的gcc正在重寫中，為了與llvm/clang更好的競爭，而且gcc從5.0開始打算進行模塊化設計，所以，以後gcc內部可能會分出很多部分。<br>就現在來看，gcc大體等同於llvm+clang所提供的功能。<br>很多人特別羨慕clang那強大的錯誤診斷信息，其實gcc4.8部分信息診斷能力已經超過它了，比它更準確，所以競爭真的很好，我們可以用到好的東西了。gcc目前的問題就是缺乏模塊化設計，這是暫時落後於llvm的地方。<br>freebsd不用gcc是因為gpl協議，llvm/clang的協議更加自由，但llvm/clang目前的兼容性和參數優化等等方面和gcc還有不小差距，雖然編譯後的體積更小了(架構領先優勢)，但在性能優化方面相比gcc還有很多事情要做。</p>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">
<ul class="pagination">
	 
				
    	<li class="prev"><a href="/Artificial Intelligence/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>上一頁</a></li>
  		

        <li><a href="/archives"><i class="fa fa-archive"></i>Archive</a></li>

		
		   <li class="next"><a href="/Makefile/" class="alignright next">下一頁<i class="fa fa-arrow-circle-o-right"></i></a></li>         
        
	
</ul>
</div>

    </center>
	</div>
	
	<!-- comment -->
	
<section id="comment">
  <h2 class="title">留言</h2>

  
  	 <div id="disqus_thread">
     <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  	 </div>
  
</section>

	
	</div> <!-- col-md-9/col-md-12 -->
	
	
		<div class="col-md-3"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2015-02-23 
	</div>
	

	<!-- categories -->
    

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/gcc/">gcc<span>1</span></a></li> <li><a href="/tags/linux/">linux<span>5</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	

</div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2015 HCL
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>

<script type="text/javascript">
var disqus_shortname = 'githubforqwerty';
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>

<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<!--mathjax-->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>      


<!--leancloud page counter-->
<script>
function addCount (Counter) {
        var title = $("page-header").context.title.split('|')[0].trim();
	var url = "/" + $('.mytitle').context.URL.split("/")[3] + "/";
        var query=new AV.Query(Counter);
        //use url as unique idnetfication
        query.equalTo("url",url);
        query.find({
            success: function(results){
                if(results.length>0)
                {
                    var counter=results[0];
                    counter.fetchWhenSave(true); //get recent result
                    counter.increment("time");
                    counter.save();
                }
                else
                {
                    var newcounter=new Counter();
                    newcounter.set("title",title);
                    newcounter.set("url",url);
                    newcounter.set("time",1);
                    newcounter.save(null,{
                        success: function(newcounter){
                        //alert('New object created');
                        },
                        error: function(newcounter,error){
                        alert('Failed to create');
                        }
                        });
                }
            },
            error: function(error){
                //find null is not a error
                alert('Error:'+error.code+" "+error.message);
            }
        });
}
$(function(){
        var Counter=AV.Object.extend("Counter");
        //only increse visit counting when intering a page
	var titleName = $('h1')[0].textContent.trim()
        if ($('.mytitle').context.URL.split("/")[2] != "localhost:4000" && $('title').length == 1 && titleName != "QWERTY" && titleName != "Categories" && titleName != "Tags" && titleName != "彙整")
           addCount(Counter);
        var query=new AV.Query(Counter);
        query.descending("time");
        // the sum of popular posts
        query.limit(10); 
        query.find({
            success: function(results){
				
                    for(var i=0;i<results.length;i++)    
                    {
						//alert(results[i]);
                        var counter=results[i];
                        title=counter.get("title");
                        url=counter.get("url");
                        time=counter.get("time");
                        // add to the popularlist widget
                        showcontent=title+" ("+time+")";
                        //notice the "" in href
                        $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                    }
                },
            error: function(error){
                alert("Error:"+error.code+" "+error.message);
            }
            }
        )
        });
</script>

</body>
   </html>
